{
    "collab_server" : "",
    "contents" : "\n\n#' This function checks if all relevant python modules are available\n#'\n#' @export\n\ncheck_availability = function() {\n\n  if (reticulate::py_available() && reticulate::py_module_available(\"fuzzywuzzy\") && reticulate::py_module_available(\"difflib\")) {\n\n    TRUE\n  }\n\n  else {\n\n    FALSE\n  }\n}\n\n\n\n#' Character string sequence matching\n#'\n#'\n#' @param string1 a character string.\n#' @param string2 a character string.\n#' @export\n#' @details\n#'\n#' the \\emph{ratio} method returns a measure of the sequences' similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this\n#' is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if getMatchingBlocks() or getOpcodes() hasnâ€™t already been called,\n#' in which case you may want to try quickRatio() or realQuickRatio() first to get an upper bound.\n#'\n#' the \\emph{quick_ratio} method returns an upper bound on ratio() relatively quickly.\n#'\n#' the \\emph{real_quick_ratio} method returns an upper bound on ratio() very quickly.\n#'\n#' the \\emph{get_matching_blocks} method returns a list of triples describing matching subsequences. Each triple is of the form [i, j, n], and means that a[i:i+n] == b[j:j+n]. The triples are monotonically\n#' increasing in i and j. The last triple is a dummy, and has the value [a.length, b.length, 0]. It is the only triple with n == 0. If [i, j, n] and [i', j', n'] are adjacent triples in the list, and the second\n#' is not the last triple in the list, then i+n != i' or j+n != j'; in other words, adjacent triples always describe non-adjacent equal blocks.\n#'\n#' The \\emph{get_opcodes} method returns a list of 5-tuples describing how to turn a into b. Each tuple is of the form [tag, i1, i2, j1, j2]. The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to\n#' the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings:\n#' 'replace'   a[i1:i2] should be replaced by b[j1:j2].\n#' 'delete'    a[i1:i2] should be deleted. Note that j1 == j2 in this case.\n#' 'insert'    b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case.\n#' 'equal'     a[i1:i2] == b[j1:j2] (the sub-sequences are equal).\n#'\n#' @references  https://www.npmjs.com/package/difflib, http://stackoverflow.com/questions/10383044/fuzzy-string-comparison\n#' @docType class\n#' @importFrom R6 R6Class\n#' @import reticulate\n#' @section Methods:\n#'\n#' \\describe{\n#'  \\item{\\code{SequenceMatcher$new(string1 = NULL, string2 = NULL)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{ratio()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{quick_ratio()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{real_quick_ratio()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{get_matching_blocks()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{get_opcodes()}}{}\n#'  }\n#'\n#' @usage # init <- SequenceMatcher$new(string1 = NULL, string2 = NULL)\n#' @examples\n#'\n#' if (check_availability()) {\n#'\n#'\n#'   library(fuzzywuzzyR)\n#'\n#'   s1 = ' It was a dark and stormy night. I was all alone sitting on a red chair.'\n#'\n#'   s2 = ' It was a murky and stormy night. I was all alone sitting on a crimson chair.'\n#'\n#'   init = SequenceMatcher$new(string1 = s1, string2 = s2)\n#'\n#'   init$ratio()\n#'\n#'   init$quick_ratio()\n#'\n#'   init$real_quick_ratio()\n#'\n#'   init$get_matching_blocks()\n#'\n#'   init$get_opcodes()\n#'\n#'\n#' }\n\n\nSequenceMatcher <- R6::R6Class(\"SequenceMatcher\",\n\n                               lock_objects = FALSE,\n\n                               public = list(\n\n                                 initialize = function(string1 = NULL, string2 = NULL) {\n\n                                   self$string1 <- string1\n\n                                   self$string2 <- string2\n\n                                   if (is.null(self$string1) || is.null(self$string2)) {\n\n                                     stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F)\n                                   }\n\n                                   if (!inherits(self$string1, c('character', 'vector')) || !inherits(self$string2, c('character', 'vector'))) {\n\n                                     stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                                   }\n\n                                   private$tmp = DIFFLIB$SequenceMatcher(NULL, self$string1, self$string2)\n                                 },\n\n                                 ratio = function() {\n\n                                   return(private$tmp$ratio())\n                                 },\n\n                                 quick_ratio = function() {\n\n                                   return(private$tmp$quick_ratio())\n                                 },\n\n                                 real_quick_ratio = function() {\n\n                                   return(private$tmp$real_quick_ratio())\n                                 },\n\n                                 get_matching_blocks = function() {\n\n                                   return(private$tmp$get_matching_blocks())\n                                 },\n\n                                 get_opcodes = function() {\n\n                                   return(private$tmp$get_opcodes())\n                                 }\n                               ),\n\n                               private = list(\n\n                                 tmp = NULL\n                               )\n)\n\n\n\n#' Matches of character strings\n#'\n#' @param string a character string.\n#' @param sequence_strings a vector of character strings.\n#' @param n an integer value specifying the maximum number of close matches to return; n must be greater than 0.\n#' @param cutoff a float number in the range [0, 1], \\emph{sequence_strings} that don't score at least that similar to \\emph{string} are ignored.\n#' @details\n#' Returns a list of the best \"good enough\" matches. \\emph{string} is a sequence for which close matches are desired (typically a string), and \\emph{sequence_strings} is a list of sequences against\n#' which to match \\emph{string} (typically a list of strings).\n#' @export\n#' @references https://www.npmjs.com/package/difflib, http://stackoverflow.com/questions/10383044/fuzzy-string-comparison\n#' @examples\n#'\n#' if (check_availability()) {\n#'\n#'\n#'   library(fuzzywuzzyR)\n#'\n#'   vec = c('Frodo Baggins', 'Tom Sawyer', 'Bilbo Baggin')\n#'\n#'   str1 = 'Fra Bagg'\n#'\n#'   GetCloseMatches(string = str1, sequence_strings = vec, n = 2L, cutoff = 0.6)\n#'\n#'\n#' }\n\n\nGetCloseMatches = function(string = NULL, sequence_strings = NULL, n = 3L, cutoff = 0.6) {\n\n  if (is.null(string) || is.null(sequence_strings)) { stop(\"both parameters 'string' and 'sequence_strings' should be non-NULL\", call. = F) }\n\n  if (!inherits(string, c('character', 'vector')) || !inherits(sequence_strings, c('character', 'vector'))) {\n\n    stop(\"both parameters 'string' and 'sequence_strings' should be of type character string\", call. = F)\n  }\n\n  if (!inherits(n, c('numeric', 'integer'))) { stop(\"the 'n' parameter should be of type integer\", call. = F) }\n\n  if (!inherits(cutoff, c('double', 'numeric'))) { stop(\"the 'cutoff' parameter should be of type numeric\", call. = F) }\n\n  if (cutoff > 1.0 || cutoff <= 0.0) { stop(\"the 'cutoff' parameter should be greater than 0.0 and less than or equal to 1.0\", call. = F) }\n\n  n = as.integer(n)\n\n  tmp = DIFFLIB$get_close_matches(string, sequence_strings, n, cutoff)\n\n  return(tmp)\n}\n\n\n\n#' Fuzzy character string matching ( ratios )\n#'\n#'\n#' @param string1 a character string.\n#' @param string2 a character string.\n#' @param force_ascii allow only ASCII characters (force convert to ascii)\n#' @param full_process either TRUE or FALSE. If TRUE then it process the string by : 1. removing all but letters and numbers, 2. trim whitespace, 3. force to lower case\n#' @export\n#' @details\n#'\n#' the \\emph{Partial_token_set_ratio} method works in the following way : 1. Find all alphanumeric tokens in each string, 2. treat them as a set, 3. construct two strings of the form, <sorted_intersection><sorted_remainder>, 4. take ratios of those two strings, 5. controls for unordered partial matches (HERE partial match is TRUE)\n#'\n#' the \\emph{Partial_token_sort_ratio} method returns the ratio of the most similar substring as a number between 0 and 100 but sorting the token before comparing.\n#'\n#' the \\emph{Ratio} method returns a ration in form of an integer value based on a SequenceMatcher-like class, which is built on top of the Levenshtein package (https://github.com/miohtama/python-Levenshtein)\n#'\n#' the \\emph{QRATIO} method performs a quick ratio comparison between two strings. Runs full_process from utils on both strings. Short circuits if either of the strings is empty after processing.\n#'\n#' the \\emph{WRATIO} method returns a measure of the sequences' similarity between 0 and 100, using different algorithms. Steps in the order they occur :\n#' 1. Run full_process from utils on both strings, 2. Short circuit if this makes either string empty, 3. Take the ratio of the two processed strings (fuzz.ratio),\n#' 4. Run checks to compare the length of the strings (If one of the strings is more than 1.5 times as long as the other use partial_ratio comparisons - scale partial results by 0.9 - this makes sure only full results can return 100 -\n#' If one of the strings is over 8 times as long as the other instead scale by 0.6), 5. Run the other ratio functions (if using partial ratio functions call partial_ratio,\n#' partial_token_sort_ratio and partial_token_set_ratio scale all of these by the ratio based on length otherwise call token_sort_ratio and token_set_ratio all token based comparisons are scaled by 0.95 - on top of any partial scalars)\n#' 6. Take the highest value from these results round it and return it as an integer.\n#'\n#' the \\emph{UWRATIO} method returns a measure of the sequences' similarity between 0 and 100, using different algorithms. Same as WRatio but preserving unicode\n#'\n#' the \\emph{UQRATIO} method returns a Unicode quick ratio. It calls \\emph{QRATIO} with force_ascii set to FALSE.\n#'\n#' the \\emph{Token_sort_ratio} method returns a measure of the sequences' similarity between 0 and 100 but sorting the token before comparing\n#'\n#' the \\emph{Partial_ratio} returns the ratio of the most similar substring as a number between 0 and 100.\n#'\n#' the \\emph{Token_set_ratio} method works in the following way : 1. Find all alphanumeric tokens in each string, 2. treat them as a set, 3. construct two strings of the form, <sorted_intersection><sorted_remainder>, 4. take ratios of those two strings, 5. controls for unordered partial matches (HERE partial match is FALSE)\n#'\n#' @references  https://github.com/seatgeek/fuzzywuzzy/blob/master/fuzzywuzzy/fuzz.py\n#' @docType class\n#' @importFrom R6 R6Class\n#' @import reticulate\n#' @section Methods:\n#'\n#' \\describe{\n#'  \\item{\\code{FuzzMatcher$new()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Partial_token_set_ratio(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Partial_token_sort_ratio(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Ratio(string1 = NULL, string2 = NULL)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{QRATIO(string1 = NULL, string2 = NULL, force_ascii = TRUE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{WRATIO(string1 = NULL, string2 = NULL, force_ascii = TRUE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{UWRATIO(string1 = NULL, string2 = NULL)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{UQRATIO(string1 = NULL, string2 = NULL)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Token_sort_ratio(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Partial_ratio(string1 = NULL, string2 = NULL)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Token_set_ratio(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE)}}{}\n#'  }\n#'\n#' @usage # init <- FuzzMatcher$new()\n#' @examples\n#'\n#' if (check_availability()) {\n#'\n#'\n#'   library(fuzzywuzzyR)\n#'\n#'   s1 = \"Atlanta Falcons\"\n#'\n#'   s2 = \"New York Jets\"\n#'\n#'   init = FuzzMatcher$new()\n#'\n#'   init$Partial_token_set_ratio(string1 = s1, string2 = s2, force_ascii = TRUE, full_process = TRUE)\n#'\n#'   init$Partial_token_sort_ratio(string1 = s1, string2 = s2, force_ascii = TRUE, full_process = TRUE)\n#'\n#'   init$Ratio(string1 = s1, string2 = s2)\n#'\n#'   init$QRATIO(string1 = s1, string2 = s2, force_ascii = TRUE)\n#'\n#'   init$WRATIO(string1 = s1, string2 = s2, force_ascii = TRUE)\n#'\n#'   init$UWRATIO(string1 = s1, string2 = s2)\n#'\n#'   init$UQRATIO(string1 = s1, string2 = s2)\n#'\n#'   init$Token_sort_ratio(string1 = s1, string2 = s2, force_ascii = TRUE, full_process = TRUE)\n#'\n#'   init$Partial_ratio(string1 = s1, string2 = s2)\n#'\n#'   init$Token_set_ratio(string1 = s1, string2 = s2, force_ascii = TRUE, full_process = TRUE)\n#'\n#'\n#' }\n\n\nFuzzMatcher <- R6::R6Class(\"FuzzMatcher\",\n\n                             lock_objects = FALSE,\n\n                             public = list(\n\n                               initialize = function() {\n\n                               },\n\n                               Partial_token_set_ratio = function(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE) {\n\n                                 if (is.null(string1) || is.null(string2)) { stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F) }\n\n                                 if (!inherits(string1, c('character', 'vector')) || !inherits(string2, c('character', 'vector'))) {\n\n                                   stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                                 }\n\n                                 if (!is.logical(force_ascii)) stop(\"the 'force_ascii' parameter should be of type boolean\", call. = F)\n\n                                 if (!is.logical(full_process)) stop(\"the 'full_process' parameter should be of type boolean\", call. = F)\n\n                                 return(FUZZ$partial_token_set_ratio(string1, string2, force_ascii, full_process))\n                               },\n\n                               Partial_token_sort_ratio = function(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE) {\n\n                                 if (is.null(string1) || is.null(string2)) { stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F) }\n\n                                 if (!inherits(string1, c('character', 'vector')) || !inherits(string2, c('character', 'vector'))) {\n\n                                   stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                                 }\n\n                                 if (!is.logical(force_ascii)) stop(\"the 'force_ascii' parameter should be of type boolean\", call. = F)\n\n                                 if (!is.logical(full_process)) stop(\"the 'full_process' parameter should be of type boolean\", call. = F)\n\n                                 return(FUZZ$partial_token_sort_ratio(string1, string2, force_ascii, full_process))\n                               },\n\n                               Ratio = function(string1 = NULL, string2 = NULL) {\n\n                                 if (is.null(string1) || is.null(string2)) { stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F) }\n\n                                 if (!inherits(string1, c('character', 'vector')) || !inherits(string2, c('character', 'vector'))) {\n\n                                   stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                                 }\n\n                                 return(FUZZ$ratio(string1, string2))\n                               },\n\n                               QRATIO = function(string1 = NULL, string2 = NULL, force_ascii = TRUE) {\n\n                                 if (is.null(string1) || is.null(string2)) { stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F) }\n\n                                 if (!inherits(string1, c('character', 'vector')) || !inherits(string2, c('character', 'vector'))) {\n\n                                   stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                                 }\n\n                                 if (!is.logical(force_ascii)) stop(\"the 'force_ascii' parameter should be of type boolean\", call. = F)\n\n                                 return(FUZZ$QRatio(string1, string2, force_ascii))\n                               },\n\n                               WRATIO = function(string1 = NULL, string2 = NULL, force_ascii = TRUE) {\n\n                                 if (is.null(string1) || is.null(string2)) { stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F) }\n\n                                 if (!inherits(string1, c('character', 'vector')) || !inherits(string2, c('character', 'vector'))) {\n\n                                   stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                                 }\n\n                                 if (!is.logical(force_ascii)) stop(\"the 'force_ascii' parameter should be of type boolean\", call. = F)\n\n                                 return(FUZZ$WRatio(string1, string2, force_ascii))\n                               },\n\n                               UWRATIO = function(string1 = NULL, string2 = NULL) {\n\n                                 if (is.null(string1) || is.null(string2)) { stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F) }\n\n                                 if (!inherits(string1, c('character', 'vector')) || !inherits(string2, c('character', 'vector'))) {\n\n                                   stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                                 }\n\n                                 return(FUZZ$UWRatio(string1, string2))\n                               },\n\n                               UQRATIO = function(string1 = NULL, string2 = NULL) {\n\n                                 if (is.null(string1) || is.null(string2)) { stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F) }\n\n                                 if (!inherits(string1, c('character', 'vector')) || !inherits(string2, c('character', 'vector'))) {\n\n                                   stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                                 }\n\n                                 return(FUZZ$UQRatio(string1, string2))\n                               },\n\n                               Token_sort_ratio = function(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE) {\n\n                                 if (is.null(string1) || is.null(string2)) { stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F) }\n\n                                 if (!inherits(string1, c('character', 'vector')) || !inherits(string2, c('character', 'vector'))) {\n\n                                   stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                                 }\n\n                                 if (!is.logical(force_ascii)) stop(\"the 'force_ascii' parameter should be of type boolean\", call. = F)\n\n                                 if (!is.logical(full_process)) stop(\"the 'full_process' parameter should be of type boolean\", call. = F)\n\n                                 return(FUZZ$token_sort_ratio(string1, string2, force_ascii, full_process))\n                               },\n\n                               Partial_ratio = function(string1 = NULL, string2 = NULL) {\n\n                                 if (is.null(string1) || is.null(string2)) { stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F) }\n\n                                 if (!inherits(string1, c('character', 'vector')) || !inherits(string2, c('character', 'vector'))) {\n\n                                   stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                                 }\n\n                                 return(FUZZ$partial_ratio(string1, string2))\n                               },\n\n                               Token_set_ratio = function(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE) {\n\n                                 if (is.null(string1) || is.null(string2)) { stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F) }\n\n                                 if (!inherits(string1, c('character', 'vector')) || !inherits(string2, c('character', 'vector'))) {\n\n                                   stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                                 }\n\n                                 if (!is.logical(force_ascii)) stop(\"the 'force_ascii' parameter should be of type boolean\", call. = F)\n\n                                 if (!is.logical(full_process)) stop(\"the 'full_process' parameter should be of type boolean\", call. = F)\n\n                                 return(FUZZ$token_set_ratio(string1, string2, force_ascii, full_process))\n                               }\n                       )\n)\n\n\n#' Utility functions\n#'\n#' @param string  a character string.\n#' @param string1 a character string.\n#' @param string2 a character string.\n#' @param input any kind of data type (applies to the \\emph{Asciidammit} method)\n#' @param force_ascii allow only ASCII characters (force convert to ascii)\n#' @param n a float number\n#' @export\n#' @details\n#'\n#' the \\emph{Full_process} processes a string by : 1. removing all but letters and numbers, 2. trim whitespace, 3. force to lower case and 4. if force_ascii == TRUE, force convert to ascii\n#'\n#' the \\emph{INTR} method returns a correctly rounded integer\n#'\n#' the \\emph{Make_type_consistent} method converts both objects if they aren't either both string or unicode instances to unicode\n#'\n#' the \\emph{Asciidammit} performs ascii dammit using the following expression \\emph{bad_chars = str(\"\").join([chr(i) for i in range(128, 256)])}. Applies to any kind of R data type.\n#'\n#' the \\emph{Asciionly} method returns the same result as the \\emph{Asciidammit} method but for character strings using the python \\emph{.translate()} function.\n#'\n#' the \\emph{Validate_string} method checks that the input has length and that length is greater than 0\n#'\n#' Some of the utils functions are used as secondary methods in the \\emph{FuzzExtract} class. See the examples of the \\emph{FuzzExtract} class for more details.\n#'\n#' @references  https://github.com/seatgeek/fuzzywuzzy/blob/master/fuzzywuzzy/utils.py\n#' @docType class\n#' @importFrom R6 R6Class\n#' @import reticulate\n#' @section Methods:\n#'\n#' \\describe{\n#'  \\item{\\code{FuzzUtils$new()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Full_process(string = NULL, force_ascii = TRUE)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{INTR(n = 2.0)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Make_type_consistent(string1 = NULL, string2 = NULL)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Asciidammit(input = NULL)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Asciionly(string = NULL)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Validate_string(string = NULL)}}{}\n#'  }\n#'\n#' @usage # init <- FuzzUtils$new()\n#' @examples\n#'\n#' if (check_availability()) {\n#'\n#'\n#'   library(fuzzywuzzyR)\n#'\n#'   s1 = 'Frodo Baggins'\n#'\n#'   s2 = 'Bilbo Baggin'\n#'\n#'   init = FuzzUtils$new()\n#'\n#'   init$Full_process(string = s1, force_ascii = TRUE)\n#'\n#'   init$INTR(n = 2.0)\n#'\n#'   init$Make_type_consistent(string1 = s1, string2 = s2)\n#'\n#'   #------------------------------------\n#'   # 'Asciidammit' with character string\n#'   #------------------------------------\n#'\n#'   init$Asciidammit(input = s1)\n#'\n#'   #----------------------------------------------------------------\n#'   # 'Asciidammit' with data.frame(123) [ or any kind of data type ]\n#'   #----------------------------------------------------------------\n#'\n#'   init$Asciidammit(input = data.frame(123))\n#'\n#'   init$Asciionly(string = s1)\n#'\n#'   init$Validate_string(string = s2)\n#'\n#'\n#' }\n\n\nFuzzUtils <- R6::R6Class(\"FuzzUtils\",\n\n                           lock_objects = FALSE,\n\n                           public = list(\n\n                             initialize = function() {\n\n                             },\n\n                             Full_process = function(string = NULL, force_ascii = TRUE) {\n\n                               if (is.null(string)) { stop(\"the 'string' parameter should be non-NULL\", call. = F) }\n\n                               if (!inherits(string, c('character', 'vector'))) {\n\n                                 stop(\"the 'string' parameter should be of type character string\", call. = F)\n                               }\n\n                               if (!is.logical(force_ascii)) stop(\"the 'force_ascii' parameter should be of type boolean\", call. = F)\n\n                               return(UTILS$full_process(string, force_ascii))\n                             },\n\n                             INTR = function(n = 2.0) {\n\n                               if (!inherits(n, c('double', 'numeric', 'integer'))) { stop(\"the 'n' parameter should be of type numeric\", call. = F) }\n\n                               return(UTILS$intr(n))\n                             },\n\n                             Make_type_consistent = function(string1 = NULL, string2 = NULL) {\n\n                               if (is.null(string1) || is.null(string2)) { stop(\"both parameters 'string1' and 'string2' should be non-NULL\", call. = F) }\n\n                               if (!inherits(string1, c('character', 'vector')) || !inherits(string2, c('character', 'vector'))) {\n\n                                 stop(\"both parameters 'string1' and 'string2' should be of type character string\", call. = F)\n                               }\n\n                               return(UTILS$make_type_consistent(string1, string2))\n                             },\n\n\n                             Asciidammit = function(input = NULL) {\n\n                               return(UTILS$asciidammit(input))\n                             },\n\n\n                             Asciionly = function(string = NULL) {\n\n                               if (is.null(string)) { stop(\"the 'string' parameter should be non-NULL\", call. = F) }\n\n                               if (!inherits(string, c('character', 'vector'))) {\n\n                                 stop(\"the 'string' parameter should be of type character string\", call. = F)\n                               }\n\n                               return(UTILS$asciionly(string))\n                             },\n\n\n                             Validate_string = function(string = NULL) {\n\n                               if (is.null(string)) { stop(\"the 'string' parameter should be non-NULL\", call. = F) }\n\n                               if (!inherits(string, c('character', 'vector'))) {\n\n                                 stop(\"the 'string' parameter should be of type character string\", call. = F)\n                               }\n\n                               return(UTILS$validate_string(string))\n                             }\n                           )\n)\n\n\n\n#' secondary function for the 'FuzzExtract' class\n#'\n#' @keywords internal\n\ncheck_scorer = function(scorer) {\n\n  if (!is.null(scorer)) {\n\n    if (!inherits(scorer, 'function')) { stop(\"the 'scorer' parameter should be of type function\", call. = F) }\n\n    tmp_sc = scorer\n  }\n\n  else {\n\n    tmp_init = FuzzMatcher$new()\n\n    tmp_sc = tmp_init$WRATIO            # defaults to 'FuzzMatcher.WRATIO()'\n  }\n\n  return(tmp_sc)\n}\n\n\n\n#' Fuzzy extraction from a sequence\n#'\n#' @param string  a character string.\n#' @param sequence_strings a character string vector\n#' @param contains_dupes a vector of strings that we would like to dedupe\n#' @param processor either NULL or a function of the form f(a) -> b, where a is the query or individual choice and b is the choice to be used in matching. See the examples for more details.\n#' @param scorer a function for scoring matches between the query and an individual processed choice. This should be a function of the form f(query, choice) -> int. By default, FuzzMatcher.WRATIO() is used and expects both query and choice to be strings. See the examples for more details.\n#' @param limit An integer value for the maximum number of elements to be returned. Defaults to 5L\n#' @param score_cutoff an integer value for the score threshold. No matches with a score less than this number will be returned. Defaults to 0\n#' @param threshold the numerical value (0, 100) point at which we expect to find duplicates. Defaults to 70 out of 100\n#' @export\n#' @details\n#'\n#' the \\emph{Extract} method selects the best match of a character string vector. It returns a list with the match and it's score.\n#'\n#' the \\emph{ExtractBests} method returns a list of the best matches for a sequence of character strings.\n#'\n#' the \\emph{ExtractWithoutOrder} method returns the best match of a character string vector (in python it returns a generator of tuples containing the match and it's score).\n#'\n#' the \\emph{ExtractOne} method finds the single best match above a score for a character string vector. This is a convenience method which returns the single best choice.\n#'\n#' the \\emph{Dedupe} is a convenience method which takes a character string vector containing duplicates and uses fuzzy matching to identify and remove duplicates. Specifically, it uses the \\emph{Extract} method\n#' to identify duplicates that score greater than a user defined threshold. Then, it looks for the longest item in the duplicate vector since we assume this item contains the most entity information and returns that.\n#' It breaks string length ties on an alphabetical sort. Note: as the threshold DECREASES the number of duplicates that are found INCREASES. This means that the returned deduplicated list will likely be shorter.\n#' Raise the threshold for fuzzy_dedupe to be less sensitive.\n#'\n#' @references  https://github.com/seatgeek/fuzzywuzzy/blob/master/fuzzywuzzy/process.py\n#' @docType class\n#' @importFrom R6 R6Class\n#' @import reticulate\n#' @section Methods:\n#'\n#' \\describe{\n#'  \\item{\\code{FuzzExtract$new()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Extract(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, limit = 5L)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{ExtractBests(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, score_cutoff = 0L, limit = 5L)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{ExtractWithoutOrder(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, score_cutoff = 0L)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{ExtractOne(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, score_cutoff = 0L)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{Dedupe(contains_dupes = NULL, threshold = 70L, scorer = NULL)}}{}\n#'\n#'  }\n#'\n#' @usage # init <- FuzzExtract$new()\n#' @examples\n#'\n#' if (check_availability()) {\n#'\n#'\n#'   library(fuzzywuzzyR)\n#'\n#'   word = \"new york jets\"\n#'\n#'   choices = c(\"Atlanta Falcons\", \"New York Jets\", \"New York Giants\", \"Dallas Cowboys\")\n#'\n#'   duplicat = c('Frodo Baggins', 'Tom Sawyer', 'Bilbo Baggin', 'Samuel L. Jackson',\n#'\n#'                'F. Baggins', 'Frody Baggins', 'Bilbo Baggins')\n#'\n#'   #------------\n#'   # processor :\n#'   #------------\n#'\n#'   init_proc = FuzzUtils$new()\n#'\n#'   PROC = init_proc$Full_process    # class process-method\n#'\n#'   PROC1 = tolower                  # base R function\n#'\n#'   #---------\n#'   # scorer :\n#'   #---------\n#'\n#'   init_scor = FuzzMatcher$new()\n#'\n#'   SCOR = init_scor$WRATIO\n#'\n#'\n#'   init <- FuzzExtract$new()\n#'\n#'   init$Extract(string = word, sequence_strings = choices, processor = PROC, scorer = SCOR)\n#'\n#'   init$ExtractBests(string = word, sequence_strings = choices, processor = PROC1,\n#'\n#'                     scorer = SCOR, score_cutoff = 0L, limit = 2L)\n#'\n#'   init$ExtractWithoutOrder(string = word, sequence_strings = choices, processor = PROC,\n#'\n#'                            scorer = SCOR, score_cutoff = 0L)\n#'\n#'   init$ExtractOne(string = word, sequence_strings = choices, processor = PROC,\n#'\n#'                   scorer = SCOR, score_cutoff = 0L)\n#'\n#'   init$Dedupe(contains_dupes = duplicat, threshold = 70L, scorer = SCOR)\n#'\n#'\n#' }\n\n\nFuzzExtract <- R6::R6Class(\"FuzzExtract\",\n\n                           lock_objects = FALSE,\n\n                           public = list(\n\n                             initialize = function() {\n\n                             },\n\n                             Extract = function(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, limit = 5L) {\n\n                               if (is.null(string) || is.null(sequence_strings)) { stop(\"both parameters 'string' and 'sequence_strings' should be non-NULL\", call. = F) }\n\n                               if (!inherits(string, c('character', 'vector')) || !inherits(sequence_strings, c('character', 'vector'))) {\n\n                                 stop(\"both parameters 'string' and 'sequence_strings' should be of type character string\", call. = F)\n                               }\n\n                               if (!is.null(processor)) {\n\n                                 if (!inherits(processor, 'function')) { stop(\"the 'processor' parameter should be of type function\", call. = F) }\n                               }\n\n                               tmp_sc = check_scorer(scorer)\n\n                               if (!inherits(limit, c('numeric', 'integer'))) { stop(\"the 'limit' parameter should be of type integer\", call. = F) }\n\n                               limit = as.integer(limit)\n\n                               tmp = EXTRACT$extract(string, sequence_strings, processor, tmp_sc, limit)\n\n                               return(tmp)\n                             },\n\n                             ExtractBests = function(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, score_cutoff = 0L, limit = 5L) {\n\n                               if (is.null(string) || is.null(sequence_strings)) { stop(\"both parameters 'string' and 'sequence_strings' should be non-NULL\", call. = F) }\n\n                               if (!inherits(string, c('character', 'vector')) || !inherits(sequence_strings, c('character', 'vector'))) {\n\n                                 stop(\"both parameters 'string' and 'sequence_strings' should be of type character string\", call. = F)\n                               }\n\n                               if (!is.null(processor)) {\n\n                                 if (!inherits(processor, 'function')) { stop(\"the 'processor' parameter should be of type function\", call. = F) }\n                               }\n\n                               tmp_sc = check_scorer(scorer)\n\n                               if (!inherits(score_cutoff, c('numeric', 'integer'))) { stop(\"the 'score_cutoff' parameter should be of type integer\", call. = F) }\n\n                               if (!inherits(limit, c('numeric', 'integer'))) { stop(\"the 'limit' parameter should be of type integer\", call. = F) }\n\n                               limit = as.integer(limit)\n\n                               score_cutoff = as.integer(score_cutoff)\n\n                               tmp = EXTRACT$extractBests(string, sequence_strings, processor, tmp_sc, score_cutoff, limit)\n\n                               return(tmp)\n                             },\n\n\n                             ExtractWithoutOrder = function(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, score_cutoff = 0L) {\n\n                               if (is.null(string) || is.null(sequence_strings)) { stop(\"both parameters 'string' and 'sequence_strings' should be non-NULL\", call. = F) }\n\n                               if (!inherits(string, c('character', 'vector')) || !inherits(sequence_strings, c('character', 'vector'))) {\n\n                                 stop(\"both parameters 'string' and 'sequence_strings' should be of type character string\", call. = F)\n                               }\n\n                               if (!is.null(processor)) {\n\n                                 if (!inherits(processor, 'function')) { stop(\"the 'processor' parameter should be of type function\", call. = F) }\n                               }\n\n                               tmp_sc = check_scorer(scorer)\n\n                               if (!inherits(score_cutoff, c('numeric', 'integer'))) { stop(\"the 'score_cutoff' parameter should be of type integer\", call. = F) }\n\n                               score_cutoff = as.integer(score_cutoff)\n\n                               iter_gen = EXTRACT$extractWithoutOrder(string, sequence_strings, processor, tmp_sc, score_cutoff)           # iterator-generator use the iterate() function to traverse\n\n                               iter_out = reticulate::iterate(iter_gen, f = base::identity, simplify = TRUE)\n\n                               return(iter_out)\n                             },\n\n\n                             ExtractOne = function(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, score_cutoff = 0L) {\n\n                               if (is.null(string) || is.null(sequence_strings)) { stop(\"both parameters 'string' and 'sequence_strings' should be non-NULL\", call. = F) }\n\n                               if (!inherits(string, c('character', 'vector')) || !inherits(sequence_strings, c('character', 'vector'))) {\n\n                                 stop(\"both parameters 'string' and 'sequence_strings' should be of type character string\", call. = F)\n                               }\n\n                               if (!is.null(processor)) {\n\n                                 if (!inherits(processor, 'function')) { stop(\"the 'processor' parameter should be of type function\", call. = F) }\n                               }\n\n                               tmp_sc = check_scorer(scorer)\n\n                               if (!inherits(score_cutoff, c('numeric', 'integer'))) { stop(\"the 'score_cutoff' parameter should be of type integer\", call. = F) }\n\n                               score_cutoff = as.integer(score_cutoff)\n\n                               tmp = EXTRACT$extractOne(string, sequence_strings, processor, tmp_sc, score_cutoff)\n\n                               return(tmp)\n                             },\n\n                             Dedupe = function(contains_dupes = NULL, threshold = 70L, scorer = NULL) {\n\n                               if (is.null(contains_dupes)) { stop(\"the 'contains_dupes' parameter should be non-NULL\", call. = F) }\n\n                               if (!inherits(contains_dupes, c('character', 'vector'))) {\n\n                                 stop(\"the 'contains_dupes' parameter should be of type character string vector\", call. = F)\n                               }\n\n                               tmp_sc = check_scorer(scorer)\n\n                               if (!inherits(threshold, c('numeric', 'integer'))) { stop(\"the 'threshold' parameter should be of type integer\", call. = F) }\n\n                               threshold = as.integer(threshold)\n\n                               tmp = EXTRACT$dedupe(contains_dupes, threshold, tmp_sc)\n\n                               return(tmp)                        # returns : dict_keys([...]) , use reticulate::py_str() to get the output in form of a string\n                             }\n                           )\n)\n\n",
    "created" : 1492085428655.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4243072367",
    "id" : "54AD337C",
    "lastKnownWriteTime" : 1492089377,
    "last_content_update" : 1492090832782,
    "path" : "~/Desktop/kaggle_gpu/add_GITHUB/fuzzywuzzyR/R/fuzzy_w.R",
    "project_path" : "R/fuzzy_w.R",
    "properties" : {
        "docOutlineSize" : "122",
        "docOutlineVisible" : "1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}