{
    "collab_server" : "",
    "contents" : "---\nlayout: post\ntitle: Fuzzy string Matching using fuzzywuzzyR and the reticulate package in R\ntags: [R, package, R-bloggers]\ncomments: true\n---\n\n\nI recently released an (other one) R package on CRAN - **fuzzywuzzyR** - which ports the [fuzzywuzzy](https://github.com/seatgeek/fuzzywuzzy) python library in R. \"fuzzywuzzy does fuzzy string matching by using the Levenshtein Distance to calculate the differences between sequences (of character strings).\" <br> \nThere is no *big news* here as in R already exist similar packages such as the [stringdist](https://github.com/markvanderloo/stringdist) package. Why then creating the package? Well, I intend to participate in a recently launched [kaggle competition](https://www.kaggle.com/c/quora-question-pairs) and one popular method to build features (predictors) is fuzzy string matching as explained in this [blog post](https://www.linkedin.com/pulse/duplicate-quora-question-abhishek-thakur). My (second) aim was to use the (newly released from Rstudio) [reticulate](https://github.com/rstudio/reticulate) package, which \"provides an R interface to Python modules, classes, and functions\" and makes the process of porting python code in R not cumbersome. <br>\nFirst, I'll explain the functionality of the **fuzzywuzzyR** package and then I'll give some examples on how to take advantage of the *reticulate* package in R.\n\n<br>\n\n#### **fuzzywuzzyR**\n\n<br>\n\nThe *fuzzywuzzyR* package includes R6-classes / functions for string matching,\n\n<br>\n\n##### **classes** \n\n\n<br>\n\n\n|    FuzzExtract              |   FuzzMatcher                   |  FuzzUtils                       |  SequenceMatcher        |\n| :-------------------------: |  :----------------------------: | :-----------------------------:  | :---------------------: |\n|   Extract()                 |  Partial_token_set_ratio()      | Full_process()                   | ratio()                 |\n|   ExtractBests()            |  Partial_token_sort_ratio()     | Make_type_consistent()           | quick_ratio()           |\n|   ExtractWithoutOrder()     |  Ratio()                        | Asciidammit()                    | real_quick_ratio()      |\n|   ExtractOne()              |  QRATIO()                       | Asciionly()                      | get_matching_blocks()   |\n|                             |  WRATIO()                       | Validate_string()                | get_opcodes()           |\n|                             |  UWRATIO()                      |                                  |                         |\n|                             |  UQRATIO()                      |                                  |                         |\n|                             |  Token_sort_ratio()             |                                  |                         |\n|                             |  Partial_ratio()                |                                  |                         |\n|                             |  Token_set_ratio()              |                                  |                         |\n\n\n<br>\n  \n  \n##### **functions**\n\n\n<br>\n\n| GetCloseMatches() |\n| :---------------- |\n\n<br>\n\n\nThe following code chunks / examples are part of the package documentation and give an idea on what can be done with the *fuzzywuzzyR* package,\n\n<br>\n\n\n##### *FuzzExtract*\n\n<br>\n\nEach one of the methods in the *FuzzExtract* class takes a *character string* and a *character string sequence* as input ( except for the *Dedupe* method which takes a string sequence only ) and given a *processor* and a *scorer* it returns one or more string match(es) and the corresponding score ( in the range 0 - 100 ). Information about the additional parameters (*limit*, *score_cutoff* and *threshold*) can be found in the package documentation,\n\n<br>\n\n```R\n\nlibrary(fuzzywuzzyR)\n\nword = \"new york jets\"\n\nchoices = c(\"Atlanta Falcons\", \"New York Jets\", \"New York Giants\", \"Dallas Cowboys\")\n\n\n#------------\n# processor :\n#------------\n\ninit_proc = FuzzUtils$new()      # initialization of FuzzUtils class to choose a processor\n\nPROC = init_proc$Full_process    # processor-method\n\nPROC1 = tolower                  # base R function ( as an example for a processor )\n\n#---------\n# scorer :\n#---------\n\ninit_scor = FuzzMatcher$new()    # initialization of the scorer class\n\nSCOR = init_scor$WRATIO          # choosen scorer function\n\n\ninit <- FuzzExtract$new()        # Initialization of the FuzzExtract class\n\ninit$Extract(string = word, sequence_strings = choices, processor = PROC, scorer = SCOR)\n  \n```\n  \n\n  \n```R\n\n# example output\n  \n  [[1]]\n[[1]][[1]]\n[1] \"New York Jets\"\n\n[[1]][[2]]\n[1] 100\n\n\n[[2]]\n[[2]][[1]]\n[1] \"New York Giants\"\n\n[[2]][[2]]\n[1] 79\n\n\n[[3]]\n[[3]][[1]]\n[1] \"Atlanta Falcons\"\n\n[[3]][[2]]\n[1] 29\n\n\n[[4]]\n[[4]][[1]]\n[1] \"Dallas Cowboys\"\n\n[[4]][[2]]\n[1] 22\n  \n```\n\n```R\n\n# extracts best matches (limited to 2 matches)\n\ninit$ExtractBests(string = word, sequence_strings = choices, processor = PROC1,\n\n                  scorer = SCOR, score_cutoff = 0L, limit = 2L)\n                  \n```\n\n```R\n\n[[1]]\n[[1]][[1]]\n[1] \"New York Jets\"\n\n[[1]][[2]]\n[1] 100\n\n\n[[2]]\n[[2]][[1]]\n[1] \"New York Giants\"\n\n[[2]][[2]]\n[1] 79\n\n```\n\n```R\n\n# extracts matches without keeping the output order\n\ninit$ExtractWithoutOrder(string = word, sequence_strings = choices, processor = PROC,\n\n                         scorer = SCOR, score_cutoff = 0L)\n\n```\n\n\n```R\n\n[[1]]\n[[1]][[1]]\n[1] \"Atlanta Falcons\"\n\n[[1]][[2]]\n[1] 29\n\n\n[[2]]\n[[2]][[1]]\n[1] \"New York Jets\"\n\n[[2]][[2]]\n[1] 100\n\n\n[[3]]\n[[3]][[1]]\n[1] \"New York Giants\"\n\n[[3]][[2]]\n[1] 79\n\n\n[[4]]\n[[4]][[1]]\n[1] \"Dallas Cowboys\"\n\n[[4]][[2]]\n[1] 22\n\n```\n\n\n```R\n\n# extracts first result \n\ninit$ExtractOne(string = word, sequence_strings = choices, processor = PROC,\n\n                scorer = SCOR, score_cutoff = 0L)\n\n```\n\n\n```R\n\n[[1]]\n[1] \"New York Jets\"\n\n[[2]]\n[1] 100\n\n```\n<br>\n\nThe *dedupe* method removes duplicates from a sequence of character strings using fuzzy string matching, \n\n<br>\n\n```R\n\nduplicat = c('Frodo Baggins', 'Tom Sawyer', 'Bilbo Baggin', 'Samuel L. Jackson',\n\n             'F. Baggins', 'Frody Baggins', 'Bilbo Baggins')\n\n\ninit$Dedupe(contains_dupes = duplicat, threshold = 70L, scorer = SCOR)\n\n```\n\n\n```R\n\n[1] \"Frodo Baggins\"     \"Samuel L. Jackson\" \"Bilbo Baggins\"     \"Tom Sawyer\"\n\n```\n\n<br>\n\n##### *FuzzMatcher*\n\n<br>\n\nEach one of the methods in the *FuzzMatcher* class takes two *character strings* (string1, string2) as input and returns a score ( in range 0 to 100 ). Information about the additional parameters (*force_ascii*, *full_process* and *threshold*) can be found in the package documentation,\n\n```R\n\ns1 = \"Atlanta Falcons\"\n\ns2 = \"New York Jets\"\n\ninit = FuzzMatcher$new()          initialization of FuzzMatcher class\n\ninit$Partial_token_set_ratio(string1 = s1, string2 = s2, force_ascii = TRUE, full_process = TRUE)\n\n# example output\n\n[1] 31\n\n```\n```R\n\ninit$Partial_token_sort_ratio(string1 = s1, string2 = s2, force_ascii = TRUE, full_process = TRUE)\n\n\n[1] 31\n\n```\n\n```R\n\ninit$Ratio(string1 = s1, string2 = s2)\n\n[1] 21\n\n```\n\n```R\n\ninit$QRATIO(string1 = s1, string2 = s2, force_ascii = TRUE)\n\n[1] 29\n\n```\n\n```R\n\ninit$WRATIO(string1 = s1, string2 = s2, force_ascii = TRUE)\n\n[1] 29\n\n```\n\n```R\n\ninit$UWRATIO(string1 = s1, string2 = s2)\n\n[1] 29\n\n```\n\n```R\n\ninit$UQRATIO(string1 = s1, string2 = s2)\n\n[1] 29\n\n```\n\n```R\n\ninit$Token_sort_ratio(string1 = s1, string2 = s2, force_ascii = TRUE, full_process = TRUE)\n\n[1] 29\n\n```\n\n```R\n\n\ninit$Partial_ratio(string1 = s1, string2 = s2)\n\n[1] 23\n\n```\n\n```R\n\ninit$Token_set_ratio(string1 = s1, string2 = s2, force_ascii = TRUE, full_process = TRUE)\n\n[1] 29\n\n```\n\n<br>\n\n##### *FuzzUtils*\n\n<br>\n\nThe *FuzzUtils* class includes a number of utility methods, from which the *Full_process* method is from greater importance as besides its main functionality it can also be used as a secondary function in some of the other fuzzy matching classes,\n\n<br>\n\n```R\n\ns1 = 'Frodo Baggins'\n\ninit = FuzzUtils$new()\n\ninit$Full_process(string = s1, force_ascii = TRUE)\n\n```\n\n```R\n\n# example output\n\n[1] \"frodo baggins\"\n\n```\n\n<br>\n\n##### *GetCloseMatches*\n\n<br>\n\nThe *GetCloseMatches* method returns a list of the best \"good enough\" matches. The parameter *string* is a sequence for which close matches are desired (typically a character string), and *sequence_strings* is a list of sequences against which to match the parameter *string* (typically a list of strings).\n\n<br>\n\n```R\n\nvec = c('Frodo Baggins', 'Tom Sawyer', 'Bilbo Baggin')\n\nstr1 = 'Fra Bagg'\n\nGetCloseMatches(string = str1, sequence_strings = vec, n = 2L, cutoff = 0.6)\n\n\n```\n\n```R\n\n[1] \"Frodo Baggins\"\n\n```\n\n\n<br>\n\n##### *SequenceMatcher*\n\n<br>\n\nThe *SequenceMatcher* class is based on [difflib](https://www.npmjs.com/package/difflib) which comes by default installed with python and includes the following fuzzy string matching methods,\n\n<br>\n\n\n```R\n\ns1 = ' It was a dark and stormy night. I was all alone sitting on a red chair.'\n\ns2 = ' It was a murky and stormy night. I was all alone sitting on a crimson chair.'\n\ninit = SequenceMatcher$new(string1 = s1, string2 = s2)\n\ninit$ratio()\n\n[1] 0.9127517\n\n```\n\n```R\n\ninit$quick_ratio()\n\n[1] 0.9127517\n\n```\n\n```R\n\ninit$real_quick_ratio()\n\n[1] 0.966443 \n\n```\n<br>\n\nThe *get_matching_blocks* and *get_opcodes* return triples and 5-tuples describing matching subsequences. More information can be found in the [Python's difflib module](https://www.npmjs.com/package/difflib) and in the *fuzzywuzzyR* package documentation.\n\n<br>\n\nA last think to note here is that the mentioned fuzzy string matching classes can be parallelized using the base R *parallel* package. For instance, the following *MCLAPPLY_RATIOS* function can take two vectors of character strings (QUERY1, QUERY2) and return the scores for each method of the *FuzzMatcher* class,\n\n<br>\n\n```R\n\nMCLAPPLY_RATIOS = function(QUERY1, QUERY2, class_fuzz = 'FuzzMatcher', method_fuzz = 'QRATIO', threads = 1, ...) {\n\n  init <- eval(parse(text = paste0(class_fuzz, '$new()')))\n\n  METHOD = paste0('init$', method_fuzz)\n\n  if (threads == 1) {\n\n    res_qrat = lapply(1:length(QUERY1), function(x) do.call(eval(parse(text = METHOD)), list(QUERY1[[x]], QUERY2[[x]], ...)))}\n\n  else {\n\n    res_qrat = parallel::mclapply(1:length(QUERY1), function(x) do.call(eval(parse(text = METHOD)), list(QUERY1[[x]], QUERY2[[x]], ...)), mc.cores = threads)\n  }\n\n  return(res_qrat)\n}\n\n```\n<br>\n\n```R\n\nquery1 = c('word1', 'word2', 'word3')\n\nquery2 = c('similarword1', 'similar_word2', 'similarwor')\n\nquer_res = MCLAPPLY_RATIOS(query1, query2, class_fuzz = 'FuzzMatcher', method_fuzz = 'QRATIO', threads = 1)\n\nunlist(quer_res)\n\n```\n\n```R\n\n# example output\n\n[1] 59 56 40\n\n```\n\n\n<br><br>\n\n#### **reticulate** package\n\n<br>\n\nMy personal opinion is that the newly released [reticulate](https://github.com/rstudio/reticulate) package is *good news* (for all R-users with minimal knowledge of python) and *bad news* (for package maintainers whose packages do not cover the full spectrum of a subject in comparison to an existing python library) at the same time. I'll explain this in the following two examples.\n\n<br>\n\nAs an R user I'd always liked to have a *truncated svd* function similar to the one of the [sklearn](http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.TruncatedSVD.html) python library. So, now in R using the reticulate package and the [mnist data](https://github.com/mlampros/DataSets) set one can do,\n\n<br>\n\n```R\n\nreticulate::py_module_available('sklearn')       # check that 'sklearn' is available in your OS\n\n[1] TRUE\n\n```\n\n\n```R\n\ndim(mnist)                # after downloading and open the data from the previous link\n\n70000   785\n\n```\n\n```R\n\nmnist = as.matrix(mnist)                                  # convert to matrix\n\ntrunc_SVD = reticulate::import('sklearn.decomposition')\n\nres_svd = trunc_SVD$TruncatedSVD(n_components = 100L, n_iter = 5L, random_state = 1L)\n\nres_svd$fit(mnist)\n\n# TruncatedSVD(algorithm='randomized', n_components=100, n_iter=5,\n#       random_state=1, tol=0.0)\n       \n```\n\n```R\n\nout_svd = res_svd$transform(mnist)\n\nstr(out_svd)\n\n# num [1:70000, 1:100] 1752 1908 2289 2237 2236 ...\n\n```\n\n```R\n\nclass(out_svd)\n\n# [1] \"matrix\"\n\n```\n<br>\n\nto receive the desired output ( a matrix with 70000 rows and 100 columns (components) ).\n\n<br>\n\nAs a package maintainer, I do receive from time to time e-mails from users of my packages. In one of them a user asked me if the hog function of the [OpenImageR](https://github.com/mlampros/OpenImageR) package is capable of plotting the hog features. Actually not, but now an R-user can, for instance, use the [scikit-image](http://scikit-image.org/) python library to [plot the hog-features](http://scikit-image.org/docs/dev/auto_examples/features_detection/plot_hog.html) using the following code chunk,\n\n<br>\n\n```R\n\nreticulate::py_module_available(\"skimage\")             # check that 'sklearn' is available in your OS\n\n# [1] TRUE\n\n```\n\n\n```R\n\nfeat <- reticulate::import(\"skimage.feature\")        # import module\n\ndata_sk <- reticulate::import(\"skimage.data\")        # import data\n\ncolor <- reticulate::import(\"skimage.color\")         # import module to plot    \n\ntmp_im = data_sk$astronaut()                         # import specific image data ('astronaut')\n\ndim(tmp_im)\n\n# [1] 512 512   3\n\n```\n\n```R\n\nimage = color$rgb2gray(tmp_im)                       # convert to gray\ndim(image)\n\n# [1] 512 512\n\n```\n\n```R\n\nres = feat$hog(image, orientations = 8L, pixels_per_cell = c(16L, 16L), cells_per_block = c(1L, 1L), visualise=T)\nstr(res)\n\n# List of 2\n#  $ : num [1:8192(1d)] 1.34e-04 1.53e-04 6.68e-05 9.19e-05 7.93e-05 ...\n#  $ : num [1:512, 1:512] 0 0 0 0 0 0 0 0 0 0 ...\n\n```\n\n```R \n\nOpenImageR::imageShow(res[[2]])       # using the OpenImageR to plot the data\n\n\n```\n\n![](hog_plot_astronaut.png)\n\n<br>\n\nAs a final word, I think that the *reticulate* package, although not that popular yet, it will make a difference in the R-community.\n\n<br>\n\nThe *README.md* file of the *fuzzywuzzyR* package includes the SystemRequirements and detailed installation instructions for each OS. \n\nAn updated version of the fuzzywuzzyR package can be found in my [Github repository](https://github.com/mlampros/fuzzywuzzyR) and to report bugs/issues please use the following link, [https://github.com/mlampros/fuzzywuzzyR/issues](https://github.com/mlampros/fuzzywuzzyR/issues).\n\n\n<br>\n",
    "created" : 1492083743860.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1699345233",
    "id" : "6679235F",
    "lastKnownWriteTime" : 1492103297,
    "last_content_update" : 1492103297959,
    "path" : "~/Downloads/2017-04-13-fuzzywuzzyR_package.md",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "markdown"
}